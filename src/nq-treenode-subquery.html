<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/polymerfire/firebase-query.html">
<link rel="import" href="./nq-tree-node.html">

<!--
`<nq-treenode-subquery>` display a tree node with expandable/collapsible capabilities and actions menu.


-->


<dom-module id="nq-treenode-subquery">
    <template>
        <style>

            li {
                list-style-type: none;
            }

        </style>

        <firebase-query
                path="/documents"
                order-by-child="[[computeOrderByChild(subQuery, docId)]]"
                equal-to="[[computeEqualTo(subQuery, docId)]]"
                data="{{children}}" >
        </firebase-query>

        <div hidden$="[[!expanded]]">
            <template is="dom-repeat" items="[[children]]" sort="sortByName">
                <template is="dom-if" if="[[expanded]]">
                    <nq-tree-node id="root"
                                  data="[[item]]"
                                  level="[[level]]"
                                  node-query="[[subQuery]]"
                                  children-query="[[computeChildrenQuery(viewQuery)]]"
                                  view-query="[[viewQuery]]"
                                  doc-id="[[item.$key]]"
                                  view-id="[[viewId]"></nq-tree-node>
                </template>
            </template>
        </div>

    </template>

    <script>
        class NqTreenodeSubquery extends Polymer.Element {
            static get is() {
                return 'nq-treenode-subquery';
            }

            static get properties() {
                return {

                    /**
                     * The Query that this element will execute. (one of the View Query array)
                     */
                    subQuery: {
                        type: Object,
                        value () {
                            return null;
                        },
                        observer: 'subQueryChanged'
                    },

                    /**
                     * The overall query array we got from the view.
                     * Used in determining the query for the next level of child nodes
                     */
                    viewQuery: {
                        type: 'Array',
                        value () {
                            return [];
                        },
                        observer: 'viewQueryChanged'
                    },

                    /**
                     * The level we're at in terms of nested pages.
                     * Use in interpreting the location hash
                     */
                    level: {
                        type: Number
                    },

                    /**
                     * The id of the document that this node is displaying.
                     */
                    docId: {
                        type: "String",
                        value: null,
                        observer: 'docIdChanged'
                    },

                    /**
                     * The id of the view used in construction for the tree.
                     * Only used to make the expanded cookie more specific
                     */
                    viewId: {
                        type: "String"
                    },

                    /**
                     * The children that came about as a result of executing the sub query
                     */
                    children: {
                        type: 'Array',
                        value: function() {
                            return [];
                        },
                        notify: true
                        //observer: 'childrenChanged'
                    },

                    /**
                     * If the there are children we notify our parent element so it can adjust the pre-icon
                     */
                    hasChildren: {
                        type: "String",
                        notify: true
                    },

                    /**
                     * The parent element tels us if we should be displaying our children
                     */
                    expanded: {
                        type: "Boolean"
                    }
                };
            }

            static get observers() {
                return [
                    'childrenLengthChanged(children.length)'
                ];
            }

            computeOrderByChild(subQuery, docId) {
                if(!docId || !subQuery || !subQuery.where || !subQuery.where.docProp) return null;
                var value = subQuery.where.docProp;
                //console.log('computeOrderByChild: ',value);
                return value;
            }

            computeEqualTo(subQuery, docId) {
                if(!docId || !subQuery || !subQuery.where || !subQuery.where.value) return null;
                var value = subQuery.where.value;
                if(value == '$parent._id') value = this.docId;
                //console.log('computeEqualTo: ',value);
                return value;
            }
            computeChildrenQuery(viewQuery) {
                //if(this.subQuery.join) [this.subQuery.join];
                //return viewQuery;
                if(this.subQuery.recursive){
                    if(this.subQuery.recursive === 'schemaQuery') return viewQuery;
                    return this.findChildrenQueryByName(this.subQuery.recursive)
                }
                return viewQuery;
            }
            findChildrenQueryByName(queryName){
                return this.viewQuery.find(function(subQuery){
                    return(subQuery.queryName === queryName);
                });
            }
            childrenLengthChanged(length){
                //console.log('childrenLengthChanged: ', this.subQuery.queryName, length);
                if(length>0) this.hasChildren = 'yes';
                else if(this.hasChildren === 'loading') this.hasChildren = 'no';
            }

            sortByName(v1, v2) {
                //TODO use query to determine name/title
                var val1 = v1.name, val2 = v2.name;
                if (val1 === val2) return 0;
                if (val1 > val2) return 1;
                if (val1 < val2) return -1;
            }




            docIdChanged(newValue, oldValue){
                //console.log('docIdChanged: ',  this.subQuery.queryName, newValue);
            }
            childrenChanged (newValue, oldData) {
                //console.log('childrenChanged: ', this.level, newValue);
                return;
                if(newValue.length>0) this.hasChildren = 'yes';
                else if(this.hasChildren === 'loading') this.hasChildren = 'no';
            }
            subQueryChanged (newValue, oldData) {
                //console.log('subQueryChanged: ', this.level, newValue.queryName);
            }
            viewQueryChanged (newValue, oldData) {
                //console.log('viewQueryChanged: ', this.level, newValue);
            }

        }
        window.customElements.define(NqTreenodeSubquery.is, NqTreenodeSubquery);

    </script>
</dom-module>