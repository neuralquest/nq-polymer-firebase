<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../io-styles/io-styles.html">

<!--
`<io-tooltip-bubble>` is used by `<io-tooltip'>` to display tooltip bubbles.
There is only one instance of this element and it is automatically added to document root.

@demo demo/index.html Basic Demo
-->

<dom-module id="io-tooltip-bubble">
  <style>
    :host {
      display: none;
      position: fixed;
      pointer-events: none;
      transition: opacity .25s ease-in-out;
      -moz-transition: opacity .25s ease-in-out;
      -webkit-transition: opacity .25s ease-in-out;
      z-index: 100001;
    }
    #message {
      @apply(--io-bubble);
    }
  </style>
  <template>
    <div id="message">{{message}}</div>
  </template>
</dom-module>
<script>
(function() {
  var bubble = document.createElement('io-tooltip-bubble');
  document.body.appendChild(bubble);
  Polymer({
    is: 'io-tooltip-bubble',
    properties: {
      /**
       * Side to be displayed on.
       */
      side: {
        type: String,
        value: 'right',
        reflectToAttribute: true
      },
      /**
       * Message to be displayed inside the element.
       */
      message: {
        type: String,
        value: ''
      }
    },
    ready: function() {
      this.__handleMessage = this._handleMessage.bind(this);
    },
    attached: function() {
      document.addEventListener('io-tooltip', this.__handleMessage);
    },
    detached: function() {
      document.removeEventListener('io-tooltip', this.__handleMessage);
    },
    _handleMessage: function(event) {
      if (event.detail.message) {
        this.message = event.detail.message;
        if (event.detail.width) {
          this.style.maxWidth = event.detail.width + 'px';
        } else {
          this.style.maxWidth = 'inherit';
        }
        this.style.display = 'inline-block';
        this.style.opacity = 0;

        this.async(function() {
          var bblRect = this.getBoundingClientRect();
          var srcRect = event.target._parent.getBoundingClientRect();

          this.side = event.detail.side || 'right';

          if (this.side === 'top' && srcRect.top - bblRect.height - 4 < 0) {
            this.side = 'bottom';
          } else if (this.side === 'right' && srcRect.right + bblRect.width + 4 > window.innerWidth) {
            this.side = 'left';
          } else if (this.side === 'bottom' && srcRect.bottom + bblRect.height + 4 > window.innerHeight) {
            this.side = 'top';
          } else if (this.side === 'left' && srcRect.left - bblRect.width - 4 < 0) {
            this.side = 'right';
          }

          this.style.opacity = 1;

          switch (this.side) {
            case 'top':
              this.style.left = srcRect.left + srcRect.width / 2 - bblRect.width / 2 + 'px';
              this.style.top = srcRect.top - bblRect.height - 4 + 'px';
              break;
            case 'right':
              this.style.left = srcRect.left + srcRect.width + 4 + 'px';
              this.style.top = srcRect.top + srcRect.height / 2 - bblRect.height / 2 + 'px';
              break;
            case 'bottom':
              this.style.left = srcRect.left + srcRect.width / 2 - bblRect.width / 2 + 'px';
              this.style.top = srcRect.bottom + 4 + 'px';
              break;
            case 'left':
              this.style.left = srcRect.left - bblRect.width - 4 + 'px';
              this.style.top = srcRect.top + srcRect.height / 2 - bblRect.height / 2 + 'px';
              break;
            case 'center':
              this.style.left = srcRect.left + srcRect.width / 2 - bblRect.width / 2 + 'px';
              this.style.top = srcRect.top + srcRect.height / 2 - bblRect.height / 2 + 'px';
              break;
          }
        });
      } else {
        this.style.display = 'none';
        this.message = '';
      }
    }
  });
}());
</script>
